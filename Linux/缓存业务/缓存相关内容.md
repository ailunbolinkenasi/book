# 缓存相关内容


## 缓存选型


## 缓存模式
### 数据一致性
Storage和Cache同步更新容易出现数据不一致
> 强调一点： 其实并不建议将`Redis`这种缓存性数据库去开启`AOF`和`RDB`,因为本身缓存就属于可丢性数据,缓存作为一种加速手段,他不应该是是一种强依赖的。如果你想把Redis作为一个高性能的KB去使用,可以用`Redis`+`Rocksdb`去做一个`Storage`。

**提一个问题: 先更新缓存还是先更新数据库?**
假设我们先更新缓存
1. 缓存更新完成以后,数据库提交修改失败了(你尴尬不?)
2. 用户从缓存中读到的数据已经是更新后的缓存数据,这数据对于用户来讲是有效的,这是个很恶心的操作啊!

一般来说,现在的标准缓存模型是`Cache Aside`,也就是当我们读缓存没有命中时的回填操作,和修改数据同步更新缓存,包括消息队列的异步补偿缓存, 都无法满足`Happens Before`会存在相互覆盖的情况。

#### FaceBook处理缓存一致性的方案
Facebook采用Cache Aside Pattern,如果数据有变更,先更新数据库,在过期缓存,这种是比较常用的方案。并没有保证数据库和缓存的强一致性,个人认为是合理的。只要保证强一致，必然会牺牲掉性能，这是无法避免的。

**租约机制解决热点key频繁过期缓存的问题**
通过租约机制,在一个请求缓存无效命中的时候,可以从cache先获取到关于这个key的一个租约,然后去查询数据库,更新缓存等操作。租约类似于一个锁，在其他请求也过来读这个key的时候，发现这个key上面有租约token,可以在这个租约上面建立监听,并设置过期时间10秒,一般第一个持有租约的线程在最多几十毫秒就会返回,把这个key重新放到缓存里面然后其他线程可以得到通知,直接从cache server里面获取数据。

### 多级缓存
微服务拆分细力度原子业务下的整合服务(聚合服务),用于提供粗颗粒度的接口,以及增加二级缓存加速,减少RPC的网络请求和延迟。
**保证多级缓存的一致性**
- 清理优先级是有要求的,先优先清理下游缓存然后在清理上游缓存
- 下游缓存的过期时间要大于上游,里面回源穿透
### 热点缓存
对于热点缓存Key的解决思路
1. 小表广播: 从`RemoteCache`提升为`LocalCache`,通过APP定时进行更新。
2. 主动监控防御预热: 比如直播间高在线情况进行直接外挂防御。
3. 多Cluster支持: 使用多副本,减少节点热点多的问题。
### 穿透缓存
- `singlefly`: 对关键字进行一致性Hash,使其某个维度的Key一定命中某个节点,然后在节点内使用互斥锁,保证回源。
- 分布式锁: 不推荐了
- 队列: 如果Cache Miss,交给一个队列聚合一个Key,来Load数据回写缓存,对于miss当前请求可以使用`singlefly`进行回源
## 缓存技巧
1. 易读性的前提下,Key设置尽可能小,减少资源的照用。redis的value可以用`int`就尽量不要用`string`,对于小于N的`value`,redis内部有`shared_object`机制
2. 拆分key,主要是用在redis使用hashes情况下。同一个hashes key 会落到同一个服务节点,hashes过大会导致内存及请求分布不均匀
3. 空缓存设置,对于部分数据可能数据库始终为空,这时应该设置空缓存,避免每次请求缓存miss都直接进入数据库
### Redis缓存技巧
1. 增量更新一致性: Expire、ZADD、HSET等,保证索引结构体无比存在的情况下去操作新增数据,操作前应当先延期在更新。
2. BITSET：存储每日登录用户,单个标记位置(boolean),为了避免单个过大或者热点数据,需要使用region sharding
3. List: 抽奖的奖池、弹幕用于类似Stack Push/POP操作
4. 避免超大Value
5. Hashs：一般用存放关注Filed,国小的时候会使用压缩列表,过大的时候容易导致rehash内存浪费。